# Pruebas para MySQL

## Resumen

Las vulnerabilidades de [Inyección SQL](https://owasp.org/www-community/attacks/SQL_Injection) ocurren cuando la entrada se utiliza en la construcción de una consulta SQL sin ser adecuadamente restringida o sanitizada. El uso de SQL dinámico (la construcción de consultas SQL mediante concatenación de cadenas) abre la puerta a estas vulnerabilidades. La inyección SQL permite a un atacante acceder a los servidores SQL. Permite la ejecución de código SQL bajo los privilegios del usuario utilizado para conectarse a la base de datos.

El *servidor MySQL* tiene algunas particularidades para que algunos exploits necesiten ser especialmente personalizados para esta aplicación. Ese es el tema de esta sección.

## Cómo probar

Cuando se encuentra una vulnerabilidad de inyección SQL en una aplicación respaldada por una base de datos MySQL, hay una serie de ataques que podrían realizarse dependiendo de la versión de MySQL y los privilegios del usuario en el DBMS.

MySQL viene con al menos cuatro versiones que se utilizan en producción en todo el mundo, `3.23.x`, `4.0.x`, `4.1.x` y `5.0.x`. Cada versión tiene un conjunto de características proporcional al número de versión.

- Desde la versión 4.0: UNION
- Desde la versión 4.1: Subconsultas
- Desde la versión 5.0: Procedimientos almacenados, funciones almacenadas y la vista llamada `INFORMATION_SCHEMA`
- Desde la versión 5.0.2: Disparadores

Debe notarse que para versiones de MySQL anteriores a 4.0.x, solo podrían usarse ataques de inyección ciega booleana o basada en tiempo, ya que la funcionalidad de subconsultas o declaraciones `UNION` no estaban implementadas.

De ahora en adelante, asumiremos que hay una vulnerabilidad clásica de inyección SQL, que puede ser activada por una solicitud similar a la descrita en la Sección sobre [Pruebas para Inyección SQL](05-Testing_for_SQL_Injection.md).

`https://www.example.com/page.php?id=2`

### El problema de las comillas simples

Antes de aprovechar las características de MySQL, debe considerarse cómo las cadenas podrían representarse en una declaración, ya que a menudo las aplicaciones web escapan comillas simples.

El escape de comillas de MySQL es el siguiente:

`'Una cadena con \'comillas\''`

Es decir, MySQL interpreta apóstrofes escapados `\'` como caracteres y no como metacaracteres.

Así que si la aplicación, para funcionar correctamente, necesita usar cadenas constantes, dos casos deben diferenciarse:

1. La aplicación web escapa comillas simples `'` => `\'`
2. La aplicación web no escapa comillas simples `'` => `'`

En MySQL, hay una forma estándar de evitar la necesidad de comillas simples, teniendo una cadena constante declarada sin la necesidad de comillas simples.

Supongamos que queremos saber el valor de un campo llamado `password` en un registro, con una condición como la siguiente:

1. password like `'A%'`
2. Los valores ASCII en un hex concatenado:
    `password LIKE 0x4125`
3. La función char():
    `password LIKE CHAR(65,37)`

### Consultas mixtas múltiples

Los conectores de biblioteca de MySQL no admiten múltiples consultas separadas por `;` por lo que no hay forma de inyectar múltiples comandos SQL no homogéneos dentro de una sola vulnerabilidad de inyección SQL como en Microsoft SQL Server.

Por ejemplo, la siguiente inyección resultará en un error:

`1 ; update tablename set code='javascript code' where 1 --`

### Recopilación de información

#### Identificación de MySQL

Por supuesto, lo primero que saber es si hay un DBMS MySQL como base de datos backend. El servidor MySQL tiene una característica que se utiliza para permitir que otros DBMS ignoren una cláusula en el dialecto MySQL. Cuando un bloque de comentario `'/**/'` contiene un signo de exclamación `'/*! sql here*/'` es interpretado por MySQL, y se considera como un bloque de comentario normal por otros DBMS como se explica en el [manual de MySQL](https://dev.mysql.com/doc/refman/8.0/en/comments.html).

Ejemplo:

`1 /*! and 1=0 */`

> Si MySQL está presente, la cláusula dentro del bloque de comentario será interpretada.

#### Versión

Hay tres formas de obtener esta información:

1. Usando la variable global `@@version`
2. Usando la función [VERSION()](https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_version)
3. Usando identificación de comentario con un número de versión `/*!40110 and 1=0*/`

que significa

```sql
if(version >= 4.1.10)
   add 'and 1=0' to the query.
```

Estas son equivalentes ya que el resultado es el mismo.

Inyección en banda:

`1 AND 1=0 UNION SELECT @@version /*`

Inyección inferencial:

`1 AND @@version like '4.0%'`

La respuesta contendría algo como:

`5.0.22-log`

#### Usuario de inicio de sesión

Hay dos tipos de usuarios en los que confía el servidor MySQL.

1. [USER()](https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_user): el usuario conectado al servidor MySQL.
2. [CURRENT_USER()](https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_current-user): el usuario interno que está ejecutando la consulta.

Hay alguna diferencia entre 1 y 2. La principal es que un usuario anónimo podría conectarse (si se permite) con cualquier nombre, pero el usuario interno de MySQL es un nombre vacío (''). Otra diferencia es que un procedimiento almacenado o una función almacenada se ejecutan como el usuario creador, si no se declara en otro lugar. Esto puede conocerse usando `CURRENT_USER`.

Inyección en banda:

`1 AND 1=0 UNION SELECT USER()`

Inyección inferencial:

`1 AND USER() like 'root%'`

La respuesta contendría algo como:

`user@hostname`

#### Nombre de la base de datos en uso

Hay la función nativa `DATABASE()`

Inyección en banda:

`1 AND 1=0 UNION SELECT DATABASE()`

Inyección inferencial:

`1 AND DATABASE() like 'db%'`

> Resultado esperado, Una cadena como esta:
>
> `dbname`

#### INFORMATION_SCHEMA

Desde MySQL 5.0 se creó una vista llamada [INFORMATION_SCHEMA](https://dev.mysql.com/doc/refman/8.0/en/information-schema.html). Permite obtener toda la información sobre bases de datos, tablas y columnas, así como procedimientos y funciones.

| Tables_in_INFORMATION_SCHEMA | DESCRIPTION |
|------------------------------|-------------|
| SCHEMATA  | Todas las bases de datos que el usuario tiene (al menos) SELECT_priv |
| SCHEMA_PRIVILEGES  | Los privilegios que el usuario tiene para cada DB |
| TABLES  | Todas las tablas que el usuario tiene (al menos) SELECT_priv |
| TABLE_PRIVILEGES | Los privilegios que el usuario tiene para cada tabla |
| COLUMNS | Todas las columnas que el usuario tiene (al menos) SELECT_priv |
| COLUMN_PRIVILEGES | Los privilegios que el usuario tiene para cada columna |
| VIEWS | Todas las columnas que el usuario tiene (al menos) SELECT_priv |
| ROUTINES | Procedimientos y funciones (necesita EXECUTE_priv) |
| TRIGGERS | Disparadores (necesita INSERT_priv) |
| USER_PRIVILEGES | Privilegios que tiene el usuario conectado |

Toda esta información podría extraerse usando técnicas conocidas como se describe en la sección de Inyección SQL.

### Vectores de ataque

#### Escribir en un archivo

Si el usuario conectado tiene privilegios `FILE` y las comillas simples no están escapadas, la cláusula `into outfile` puede usarse para exportar resultados de consulta en un archivo.

`Select * from table into outfile '/tmp/file'`

Nota: no hay forma de evitar comillas simples rodeando un nombre de archivo. Así que si hay alguna sanitización en comillas simples como escape `\'` no habrá forma de usar la cláusula `into outfile`.

Este tipo de ataque podría usarse como una técnica fuera de banda para obtener información sobre los resultados de una consulta o para escribir un archivo que podría ejecutarse dentro del directorio del servidor web.

Ejemplo:

`1 limit 1 into outfile '/var/www/root/test.jsp' FIELDS ENCLOSED BY '//'  LINES TERMINATED BY '\n<%jsp code here%>';`

> Los resultados se almacenan en un archivo con privilegios `rw-rw-rw` propiedad del usuario y grupo de MySQL.
>
> Donde `/var/www/root/test.jsp` contendrá:
>
> `//field values//`
> `<%jsp code here%>`

#### Leer desde un archivo

`load_file` es una función nativa que puede leer un archivo cuando lo permiten los permisos del sistema de archivos. Si un usuario conectado tiene privilegios `FILE`, podría usarse para obtener el contenido de los archivos. La sanitización de escape de comillas simples puede evitarse usando técnicas descritas anteriormente.

`load_file('filename')`

> El archivo completo estará disponible para exportación usando técnicas estándar.

### Ataque de inyección SQL estándar

En una inyección SQL estándar, puede tener resultados mostrados directamente en una página como salida normal o como un error de MySQL. Usando ataques de inyección SQL ya mencionados y las características de MySQL ya descritas, la inyección SQL directa podría lograrse fácilmente a un nivel de profundidad dependiendo principalmente de la versión de MySQL que enfrenta el pentester.

Un buen ataque es conocer los resultados forzando a una función/procedimiento o al servidor mismo a lanzar un error. Una lista de errores lanzados por MySQL y en particular funciones nativas podría encontrarse en el [Manual de MySQL](https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html).

### Inyección SQL fuera de banda

La inyección fuera de banda podría lograrse usando la cláusula [`into outfile`](#write-in-a-file).

### Inyección SQL ciega

Para la inyección SQL ciega, hay un conjunto de funciones útiles proporcionadas nativamente por el servidor MySQL.

- Longitud de cadena:
    - `LENGTH(str)`
- Extraer una subcadena de una cadena dada:
    - `SUBSTRING(string, offset, #chars_returned)`
- Inyección ciega basada en tiempo:
    - BENCHMARK y SLEEP `BENCHMARK(#ofcycles,action_to_be_performed)`
    La función benchmark podría usarse para realizar ataques de tiempo cuando la inyección ciega por valores booleanos no produce resultados.
    Ver. `SLEEP()` (MySQL > 5.0.x) para una alternativa en benchmark.

Para una lista completa, consulte el [manual de MySQL](https://dev.mysql.com/doc/refman/8.0/en/functions.html)

## Herramientas

- [Bernardo Damele A. G.: sqlmap, herramienta automática de inyección SQL](https://sqlmap.org/)
- [Muhaimin Dzulfakar: MySqloit, herramienta de toma de control de inyección MySql](https://code.google.com/archive/p/mysqloit/)

## Referencias

### Documentos técnicos

- [Chris Anley: "Hackproofing MySQL"](https://www.securitylab.ru/_Article_Images/2004/HackproofingMySQL.pdf)

### Estudios de caso

- [Zeelock: Blind Injection in MySQL Databases](https://archive.cert.uni-stuttgart.de/bugtraq/2005/02/msg00289.html)