# Pruebas de inyección SQL del lado cliente

## Resumen

La inyección SQL del lado cliente ocurre cuando una aplicación implementa la tecnología [Web SQL Database](https://www.w3.org/TR/webdatabase/) y no valida correctamente la entrada ni parametriza sus variables de consulta. Esta base de datos se manipula mediante llamadas a la API de JavaScript (JS), como `openDatabase()`, que crea o abre una base de datos existente.

## Objetivos de la prueba

El siguiente escenario de prueba validará que se realiza una validación de entrada adecuada. Si la implementación es vulnerable, el atacante puede leer, modificar o eliminar información almacenada dentro de la base de datos.

## Cómo probar

### Identificar el uso de Web SQL DB

Si la aplicación probada implementa Web SQL DB, se utilizarán las siguientes tres llamadas en el núcleo del lado cliente:

- `openDatabase()`
- `transaction()`
- `executeSQL()`

El código a continuación muestra un ejemplo de la implementación de las APIs:

```javascript
var db = openDatabase(shortName, version, displayName, maxSize);

db.transaction(function(transaction) {
    transaction.executeSql('INSERT INTO LOGS (time, id, log) VALUES (?, ?, ?)', [dateTime, id, log]);
});
```

### Inyección Web SQL DB

Después de confirmar el uso de `executeSQL()`, el atacante está listo para probar y validar la seguridad de su implementación.

La implementación de Web SQL DB se basa en la [sintaxis de SQLite](https://www.sqlite.org/lang.html).

#### Bypass de condiciones

El siguiente ejemplo muestra cómo esto podría ser explotado en el lado cliente:

```javascript
// URL example: https://example.com/user#15
var userId = document.location.hash.substring(1,); // Grabs the ID without the hash -> 15

db.transaction(function(transaction){
    transaction.executeSQL('SELECT * FROM users WHERE user = ' + userId);
});
```

Para devolver información de todos los usuarios, en lugar de solo el usuario correspondiente al atacante, se podría usar: `15 OR 1=1` en el fragmento de URL.

> **_NOTA:_**  Ten cuidado al inyectar la condición OR 1=1 en una consulta SQL. Aunque esto puede ser inofensivo en el contexto inicial en el que estás inyectando, es común que las aplicaciones usen datos de una sola solicitud en múltiples consultas diferentes. Si tu condición llega a una declaración UPDATE o DELETE, por ejemplo, esto puede resultar en una pérdida accidental de datos.

Para payloads adicionales de inyección SQL, ve al escenario [Pruebas de inyección SQL](05-Testing_for_SQL_Injection.md).

## Remediation

Sigue la misma remediation de la [Sección de Remediation de Pruebas de inyección SQL](05-Testing_for_SQL_Injection.md#remediation).

## Referencias

- [W3C Web SQL Database](https://www.w3.org/TR/webdatabase/)
- [Tutorial de base de datos JavaScript de Apple](https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/SafariJSDatabaseGuide/UsingtheJavascriptDatabase/UsingtheJavascriptDatabase.html)
- [Tutorialspoint HTML5 Web SQL Database](https://www.tutorialspoint.com/html5/html5_web_sql.htm)
- [Inyección SQL del lado cliente de Portswigger](https://portswigger.net/web-security/dom-based/client-side-sql-injection)