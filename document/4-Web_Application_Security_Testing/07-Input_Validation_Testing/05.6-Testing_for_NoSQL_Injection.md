# Pruebas de Inyección NoSQL

## Resumen

Las bases de datos NoSQL proporcionan restricciones de consistencia más laxas que las bases de datos SQL tradicionales. Al requerir menos restricciones relacionales y comprobaciones de consistencia, las bases de datos NoSQL a menudo ofrecen beneficios de rendimiento y escalabilidad. Sin embargo, estas bases de datos siguen siendo potencialmente vulnerables a ataques de inyección, incluso si no utilizan la sintaxis SQL tradicional. Debido a que estos ataques de inyección NoSQL pueden ejecutarse dentro de un [lenguaje procedural](https://en.wikipedia.org/wiki/Procedural_programming), en lugar del [lenguaje declarativo SQL](https://en.wikipedia.org/wiki/Declarative_programming), los impactos potenciales son mayores que la inyección SQL tradicional.

Las llamadas a bases de datos NoSQL se escriben en el lenguaje de programación de la aplicación, una llamada API personalizada o formateadas según una convención común (como `XML`, `JSON`, `LINQ`, etc.). La entrada maliciosa dirigida a esas especificaciones puede no activar las comprobaciones de sanitización principalmente de la aplicación. Por ejemplo, filtrar caracteres especiales comunes de HTML como `< > & ;` no evitará ataques contra una API JSON, donde los caracteres especiales incluyen `/ { } :`.

Hay cientos de bases de datos NoSQL disponibles para su uso dentro de una aplicación, proporcionando APIs en una variedad de lenguajes y modelos de relación. Cada una ofrece diferentes características y restricciones. Debido a que no hay un lenguaje común entre ellas, los ejemplos de código de inyección no se aplicarán a todas las bases de datos NoSQL. Por esta razón, cualquier persona que pruebe ataques de inyección NoSQL necesitará familiarizarse con la sintaxis, el modelo de datos y el lenguaje de programación subyacente para elaborar pruebas específicas.

Los ataques de inyección NoSQL pueden ejecutarse en diferentes áreas de una aplicación que la inyección SQL tradicional. Donde la inyección SQL se ejecutaría dentro del motor de base de datos, las variantes NoSQL pueden ejecutarse dentro de la capa de aplicación o la capa de base de datos, dependiendo de la API NoSQL utilizada y el modelo de datos. Típicamente, los ataques de inyección NoSQL se ejecutarán donde la cadena de ataque se analice, evalúe o concatene en una llamada API NoSQL.

Los ataques de tiempo adicionales pueden ser relevantes para la falta de comprobaciones de concurrencia dentro de una base de datos NoSQL. Estos no se cubren bajo pruebas de inyección. En el momento de escribir esto, MongoDB es la base de datos NoSQL más ampliamente utilizada, por lo que todos los ejemplos presentarán APIs de MongoDB.

## Cómo Probar

### Pruebas de Vulnerabilidades de Inyección NoSQL en MongoDB

La API de MongoDB espera llamadas BSON (JSON Binario), e incluye una herramienta segura de ensamblaje de consultas BSON. Sin embargo, según la documentación de MongoDB, se permiten JSON no serializado y [expresiones JavaScript](https://docs.mongodb.org/manual/faq/developers/#javascript) en varios parámetros de consulta alternativos. La llamada API más comúnmente utilizada que permite entrada JavaScript arbitraria es el operador `$where`.

El operador MongoDB `$where` típicamente se utiliza como un filtro o comprobación simple, como lo es dentro de SQL.

`db.myCollection.find( { $where: "this.credits`` ``==`` ``this.debits" } );`

Opcionalmente, JavaScript también se evalúa para permitir condiciones más avanzadas.

`db.myCollection.find( { $where: function() { return obj.credits - obj.debits < 0; } } );`

### Ejemplo 1

Si un atacante pudiera manipular los datos pasados al operador `$where`, ese atacante podría incluir JavaScript arbitrario para ser evaluado como parte de la consulta MongoDB. Una vulnerabilidad de ejemplo se expone en el siguiente código, si la entrada del usuario se pasa directamente a la consulta MongoDB sin sanitización.

`db.myCollection.find( { active: true, $where: function() { return obj.credits - obj.debits < $userInput; } } );;`

Como con las pruebas de otros tipos de inyección, uno no necesita explotar completamente la vulnerabilidad para demostrar un problema. Al inyectar caracteres especiales relevantes para el lenguaje API objetivo, y observando los resultados, un probador puede determinar si la aplicación sanitizó correctamente la entrada. Por ejemplo, dentro de MongoDB, si una cadena que contiene cualquiera de los siguientes caracteres especiales se pasara sin sanitizar, activaría un error de base de datos.

`' " \ ; { }`

Con la inyección SQL normal, una vulnerabilidad similar permitiría a un atacante ejecutar comandos SQL arbitrarios, exponiendo o manipulando datos a voluntad. Sin embargo, debido a que JavaScript es un lenguaje completamente funcional, no solo permite a un atacante manipular datos, sino también ejecutar código arbitrario. Por ejemplo, en lugar de solo causar un error al probar, una explotación completa utilizaría los caracteres especiales para elaborar JavaScript válido.

Esta entrada `0;var date=new Date(); do{curDate = new Date();}while(curDate-date<10000)` insertada en `$userInput` en el código de ejemplo anterior resultaría en la siguiente función JavaScript siendo ejecutada. Esta cadena de ataque específica haría que toda la instancia MongoDB se ejecute al 100% de CPU durante 10 segundos.

`function() { return obj.credits - obj.debits < 0;var date=new Date(); do{curDate = new Date();}while(curDate-date<10000); }`

### Ejemplo 2

Incluso si la entrada utilizada dentro de las consultas está completamente sanitizada o parametrizada, hay una ruta alternativa en la que uno podría activar inyección NoSQL. Muchas instancias NoSQL tienen sus propios nombres de variables reservadas, independientes del lenguaje de programación de la aplicación.

Por ejemplo, dentro de MongoDB, la sintaxis `$where` en sí es un operador de consulta reservado. Necesita pasarse a la consulta exactamente como se muestra; cualquier alteración causaría un error de base de datos. Sin embargo, debido a que `$where` también es un nombre de variable PHP válido, puede ser posible para un atacante insertar código en la consulta creando una variable PHP llamada `$where`. La documentación de MongoDB para PHP advierte explícitamente a los desarrolladores:

Asegúrese de que para todos los operadores de consulta especiales (que comienzan con `$`) utilice comillas simples para que PHP no intente reemplazar `$exists` con el valor de la variable `$exists`.

Incluso si una consulta dependiera de ninguna entrada de usuario, como el siguiente ejemplo, un atacante podría explotar MongoDB reemplazando el operador con datos maliciosos.

`db.myCollection.find( { $where: function() { return obj.credits - obj.debits < 0; } } );`

Una forma de asignar potencialmente datos a variables PHP es vía Contaminación de Parámetros HTTP (ver: [Pruebas de Contaminación de Parámetros HTTP](04-Testing_for_HTTP_Parameter_Pollution.md)). Al crear una variable llamada `$where` vía contaminación de parámetros, uno podría activar un error de MongoDB indicando que la consulta ya no es válida. Cualquier valor de `$where` diferente de la cadena `$where` en sí, debería bastar para demostrar vulnerabilidad. Un atacante desarrollaría una explotación completa insertando lo siguiente:

`$where: function() { //JavaScript arbitrario aquí }`

## Referencias

### Cargas Útiles de Inyección

- [Lista de palabras de cargas útiles de inyección con ejemplos de Inyección NoSQL para MongoDB](https://github.com/cr0hn/nosqlinjection_wordlists)

### Documentos Técnicos

- [Bryan Sullivan de Adobe: "NoSQL, But Even Less Security"](https://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20NoSQL%20But%20Even%20Less%20Security.pdf)
- [Erlend de Bekk Consulting: Security NOSQL-injection](https://erlend.oftedal.no/blog/?blogid=110)
- [Felipe Aragon de Syhunt: "NoSQL/SSJS Injection"](https://www.syhunt.com/en/?n=Articles.NoSQLInjection)
- [Documentación de MongoDB: "¿Cómo aborda MongoDB la inyección SQL o de consultas?"](https://docs.mongodb.org/manual/faq/developers/#how-does-mongodb-address-sql-or-query-injection)
- [Documentación de PHP: "Clases de Controlador MongoDB"](https://www.php.net/manual/en/book.mongodb.php)
- [Hackeando NodeJS y MongoDB](https://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb.html)
- [Atacando NodeJS y MongoDB](https://blog.websecurify.com/2014/08/attacks-nodejs-and-mongodb-part-to.html)