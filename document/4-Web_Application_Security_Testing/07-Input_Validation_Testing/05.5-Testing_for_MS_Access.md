# Pruebas para MS Access

## Resumen

Como se explica en la sección genérica de [inyección SQL](https://owasp.org/www-community/attacks/SQL_Injection), las vulnerabilidades de inyección SQL ocurren cuando la entrada proporcionada por el usuario se utiliza durante la construcción de una consulta SQL sin ser adecuadamente restringida o sanitizada. Esta clase de vulnerabilidades permite a un atacante ejecutar código SQL bajo los privilegios del usuario que se utiliza para conectarse a la base de datos. En esta sección, se discutirán técnicas relevantes de inyección SQL que utilizan características específicas de [Microsoft Access](https://en.wikipedia.org/wiki/Microsoft_Access).

## Cómo probar

### Identificación de huellas

La identificación de la tecnología específica de la base de datos al probar aplicaciones impulsadas por SQL es el primer paso para evaluar correctamente las vulnerabilidades potenciales. Un enfoque común implica inyectar patrones de ataque de inyección SQL estándar (por ejemplo, comilla simple, comilla doble, ...) para provocar excepciones de base de datos. Suponiendo que la aplicación no maneja las excepciones con páginas personalizadas, es posible identificar el DBMS subyacente observando los mensajes de error.

Dependiendo de la tecnología web específica utilizada, las aplicaciones impulsadas por MS Access responderán con uno de los siguientes errores:

`Fatal error: Uncaught exception 'com_exception' with message Source: Microsoft JET Database Engine`

o

`Microsoft JET Database Engine error '80040e14'`

o

`Microsoft Office Access Database Engine`

En todos los casos, tenemos una confirmación de que estamos probando una aplicación que utiliza una base de datos MS Access.

### Pruebas básicas

Desafortunadamente, MS Access no admite operadores típicos que se utilizan tradicionalmente durante las pruebas de inyección SQL, incluyendo:

- Sin caracteres de comentario
- Sin consultas apiladas
- Sin operador LIMIT
- Sin operadores similares a SLEEP o BENCHMARK
- y muchos otros

Sin embargo, es posible emular esas funciones combinando múltiples operadores o utilizando técnicas alternativas. Como se mencionó, no es posible utilizar el truco de insertar los caracteres `/*`, `--` o `#` para truncar la consulta. Sin embargo, afortunadamente podemos eludir esta limitación inyectando un carácter 'null'. El uso de un byte nulo `%00` dentro de una consulta SQL resulta en que MS Access ignore todos los caracteres restantes. Esto se puede explicar considerando que todas las cadenas están terminadas en NULL en la representación interna utilizada por la base de datos. Vale la pena mencionar que el carácter `null` a veces puede causar problemas también, ya que puede truncar cadenas a nivel del servidor web. En esas situaciones, sin embargo, podemos emplear otro carácter: `0x16` (`%16` en formato codificado URL).

Considerando la siguiente consulta:

`SELECT [username],[password] FROM users WHERE [username]='$myUsername' AND [password]='$myPassword'`

Podemos truncar la consulta con las siguientes dos URLs:

- `https://www.example.com/page.asp?user=admin'%00&pass=foo`
- `https://www.example.com/page.app?user=admin'%16&pass=foo`

El operador `LIMIT` no está implementado en MS Access, sin embargo es posible limitar el número de resultados utilizando los operadores `TOP` o `LAST` en su lugar.

`https://www.example.com/page.app?id=2'+UNION+SELECT+TOP+3+name+FROM+appsTable%00`

Combinando ambos operadores, es posible seleccionar resultados específicos. La concatenación de cadenas es posible utilizando los caracteres `& (%26)` y `+ (%2b)`.

También hay muchas otras funciones que se pueden utilizar al probar inyección SQL, incluyendo pero no limitado a:

- ASC: Obtener el valor ASCII de un carácter pasado como entrada
- CHR: Obtener el carácter del valor ASCII pasado como entrada
- LEN: Devolver la longitud de la cadena pasada como parámetro
- IIF: Es la construcción IF, por ejemplo la declaración siguiente `IIF(1=1, 'a', 'b')` devuelve `a`
- MID: Esta función permite extraer subcadenas, por ejemplo la declaración siguiente `mid('abc',1,1)` devuelve `a`
- TOP: Esta función permite especificar el número máximo de resultados que la consulta debe devolver desde arriba. Por ejemplo `TOP 1` devolverá solo 1 fila.
- LAST: Esta función se utiliza para seleccionar solo la última fila de un conjunto de filas. Por ejemplo la consulta siguiente `SELECT last(*)` FROM users devolverá solo la última fila del resultado.

Algunos de estos operadores son esenciales para explotar inyecciones SQL ciegas. Para otros operadores avanzados, por favor consulte los documentos en las referencias.

#### Enumeración de atributos

Para enumerar la columna de una tabla de base de datos, es posible utilizar una técnica común basada en errores. En resumen, podemos obtener el nombre de los atributos analizando mensajes de error y repitiendo la consulta con diferentes selectores. Por ejemplo, asumiendo que conocemos la existencia de una columna, podemos también obtener el nombre de los atributos restantes con la siguiente consulta:

`' GROUP BY Id%00`

En el mensaje de error recibido, es posible observar el nombre de la siguiente columna. En este punto, podemos iterar el método hasta obtener el nombre de todos los atributos. Si no conocemos el nombre del primer atributo, aún podemos insertar un nombre de columna ficticio y obtener el nombre del primer atributo dentro del mensaje de error.

#### Obtención del esquema de la base de datos

Varias tablas del sistema existen por defecto en MS Access que pueden ser potencialmente utilizadas para obtener nombres de tablas y columnas. Desafortunadamente, en la configuración predeterminada de versiones recientes de bases de datos MS Access, estas tablas no son accesibles. Sin embargo, siempre vale la pena intentarlo:

- MSysObjects
- MSysACEs
- MSysAccessXML

Por ejemplo, si existe una vulnerabilidad de inyección SQL de unión, puede utilizar la siguiente consulta:

`' UNION SELECT Name FROM MSysObjects WHERE Type = 1%00`

Alternativamente, siempre es posible forzar bruta el esquema de la base de datos utilizando una lista de palabras estándar (por ejemplo [FuzzDb](https://github.com/fuzzdb-project/fuzzdb)).

En algunos casos, los desarrolladores o administradores del sistema no se dan cuenta de que incluir el archivo `.mdb` real dentro del directorio webroot de la aplicación puede permitir descargar toda la base de datos. Los nombres de archivos de base de datos se pueden inferir con la siguiente consulta:

`https://www.example.com/page.app?id=1'+UNION+SELECT+1+FROM+name.table%00`

donde `name` es el nombre del archivo `.mdb` y `table` es una tabla válida de la base de datos. En caso de bases de datos protegidas por contraseña, se pueden utilizar múltiples utilidades de software para crackear la contraseña. Por favor consulte las referencias.

### Pruebas de inyección SQL ciega

Las vulnerabilidades de [inyección SQL ciega](https://owasp.org/www-community/attacks/Blind_SQL_Injection) no son de ninguna manera las inyecciones SQL más fácilmente explotables al probar aplicaciones de la vida real. En caso de versiones recientes de MS Access, tampoco es factible ejecutar comandos de shell o leer/escribir archivos arbitrarios.

En caso de inyecciones SQL ciegas, el atacante solo puede inferir el resultado de la consulta evaluando diferencias de tiempo o respuestas de la aplicación. Se supone que el lector ya conoce la teoría detrás de los ataques de inyección SQL ciega, ya que la parte restante de esta sección se centrará en detalles específicos de MS Access.

Se utiliza el siguiente ejemplo:

`https://www.example.com/index.php?myId=[sql]`

donde el parámetro ID se utiliza dentro de la siguiente consulta:

`SELECT * FROM orders WHERE [id]=$myId`

Consideremos el parámetro `myId` vulnerable a inyección SQL ciega. Como atacante, queremos extraer el contenido de la columna `username` en la tabla `users`, asumiendo que ya hemos revelado el esquema de la base de datos.

Una consulta típica que se puede utilizar para inferir el primer carácter del nombre de usuario de la fila 10 es:

`https://www.example.com/index.php?id=IIF((select%20MID(LAST(username),1,1)%20from%20(select%20TOP%2010%20username%20from%20users)='a',0,'no')`

Si el primer carácter es `a`, la consulta devolverá `0` o de lo contrario la cadena `no`.

Utilizando una combinación de las funciones `IFF, MID, LAST` y `TOP`, es posible extraer el primer carácter del nombre de usuario en una fila seleccionada específicamente. Como la consulta interna devuelve un conjunto de registros, y no solo uno, no es posible utilizarla directamente. Afortunadamente, podemos combinar múltiples funciones para extraer una cadena específica.

Asumamos que queremos recuperar el nombre de usuario de la fila 10. Primero, podemos utilizar la función TOP para seleccionar las primeras diez filas utilizando la siguiente consulta:

`SELECT TOP 10 username FROM users`

Luego, utilizando este subconjunto, podemos extraer la última fila utilizando la función LAST. Una vez que tenemos solo una fila y exactamente la fila que contiene nuestra cadena, podemos utilizar las funciones IFF, MID y LAST para inferir el valor actual del nombre de usuario. En nuestro ejemplo, empleamos IFF para devolver un número o una cadena. Utilizando este truco, podemos distinguir si tenemos una respuesta verdadera o no, observando respuestas de error de la aplicación. Como `id` es numérico, la comparación con una cadena resulta en un error SQL que puede ser potencialmente filtrado por páginas `500 Internal Server Error`. De lo contrario, una página estándar `200 OK` será probablemente devuelta.

Por ejemplo, podemos tener la siguiente consulta:

`https://www.example.com/index.php?id='%20AND%201=0%20OR%20'a'=IIF((select%20MID(LAST(username),1,1)%20from%20(select%20TOP%2010%20username%20from%20users))='a','a','b')%00`

que es VERDADERA si el primer carácter es 'a' o falsa de lo contrario.

Como se mencionó, este método permite inferir el valor de cadenas arbitrarias dentro de la base de datos:

1. Probando todos los valores imprimibles, hasta encontrar una coincidencia
2. Infiriendo la longitud de la cadena utilizando la función `LEN`, o simplemente deteniéndose después de haber encontrado todos los caracteres

Las inyecciones SQL ciegas basadas en tiempo también son posibles abusando de [consultas pesadas](https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)).

## Referencias

- [Access Through Access - Brett Moore](https://packetstormsecurity.com/files/65967/Access-Through-Access.pdf.html)
- [Access SQL Injection - Brett Moore](https://seclists.org/pen-test/2003/May/74)
- [MS Access: Functions](https://www.techonthenet.com/access/functions/index_alpha.php)
- [Microsoft Access - Wikipedia](https://en.wikipedia.org/wiki/Microsoft_Access)